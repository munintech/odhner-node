// Generated by CoffeeScript 1.3.3
(function() {
  var Odhner, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  Odhner = (function() {

    function Odhner(input, base) {
      this.input = input;
      this.base = base != null ? base : 0;
      this.sanetizedInput = this.sanetizeInput(this.input);
      this.errors = [];
      this.resultValue = null;
    }

    Odhner.prototype.isValid = function() {
      return this.isValidInput();
    };

    Odhner.prototype.result = function() {
      if (this.resultValue != null) {
        return this.resultValue;
      }
      if (this.isValidInput()) {
        if (!(this.resultValue != null)) {
          this.resultValue = this.calculateValidInput();
        }
        if (isFinite(this.resultValue)) {
          return this.resultValue;
        } else {
          return 0;
        }
      } else {
        throw this.errorsInInput();
      }
    };

    Odhner.prototype.sanetizeInput = function(input) {
      var sanetizedInput;
      sanetizedInput = input;
      sanetizedInput = sanetizedInput.toString().replace(/\s/g, "");
      return sanetizedInput;
    };

    Odhner.prototype.isValidInput = function() {
      var isValid, regexContainsAdjacentOperands, regexContainsInvalidCharacters, regexContainsOperandAtEnd;
      this.resetErrors();
      regexContainsInvalidCharacters = /[^\d^\+^\-^\*^\\/^\.^\,^\(^\)]/;
      regexContainsAdjacentOperands = /[\+\-\*\\/]{2}/;
      regexContainsOperandAtEnd = /[\+\-\*\\/]$/;
      isValid = true;
      if (regexContainsInvalidCharacters.test(this.sanetizedInput)) {
        isValid = false;
        this.addError("Invalid input. The input includes some odd characters. It can only include digits (0-9), plus (+), minus (-), star (*), slash (/) and brackets \"(\" or \").\"");
      }
      if (regexContainsAdjacentOperands.test(this.sanetizedInput)) {
        isValid = false;
        this.addError('Invalid input. The input includes two adjacent operands (+, -, * or /) which the calculator do not know how to handle.');
      }
      if (regexContainsOperandAtEnd.test(this.sanetizedInput)) {
        isValid = false;
        this.addError('Invalid input. The input ends with an operand (+, -, * or /). The calculator does not know how to handle this. Would you?');
      }
      try {
        return this.resultValue = this.calculateValidInput();
      } catch (error) {
        this.addError("You did something crazy that Cal does not know how to handle. '" + (error.toString()) + ",' he says.");
        return isValid = false;
      } finally {
        return isValid;
      }
    };

    Odhner.prototype.errorsInInput = function() {
      return this.errors;
    };

    Odhner.prototype.addError = function(errorMessage) {
      return this.errors.push(errorMessage);
    };

    Odhner.prototype.resetErrors = function() {
      return this.errors = [];
    };

    Odhner.prototype.calculateValidInput = function() {
      var evalString;
      evalString = this.inputWithInferedSeparators(this.sanetizedInput);
      if (/^[\+\-\*\/]/.test(evalString)) {
        evalString = this.base + evalString;
      }
      return eval(evalString);
    };

    Odhner.prototype.inputWithInferedSeparators = function(input) {
      var element, isCriticalNumber, number, operandsAndSanetizedNumbers, originalOperandsAndNumbers, sanetizedInput, sanetizedNumber, _i, _len;
      originalOperandsAndNumbers = [];
      operandsAndSanetizedNumbers = [];
      originalOperandsAndNumbers = this.operandsAndNumbersInString(input);
      for (_i = 0, _len = originalOperandsAndNumbers.length; _i < _len; _i++) {
        element = originalOperandsAndNumbers[_i];
        if (this.isNumber(element)) {
          number = element;
          sanetizedNumber = this.numberWithOneOrNoDelimiter(number);
          if ((isCriticalNumber = this.isCriticalNumber(sanetizedNumber))) {
            sanetizedNumber = this.mostProbableNumber(sanetizedNumber);
          }
          operandsAndSanetizedNumbers.push(sanetizedNumber);
        } else {
          operandsAndSanetizedNumbers.push(element);
        }
      }
      sanetizedInput = this.compileStringFromArray(operandsAndSanetizedNumbers);
      return sanetizedInput;
    };

    Odhner.prototype.operandsAndNumbersInString = function(input) {
      var elements, regexNumberOrOperand, result;
      elements = [];
      regexNumberOrOperand = /[\d\.\,]+|[\+\-\*\\/\(\)]+/g;
      result = regexNumberOrOperand.exec(input);
      while (result != null) {
        elements.push(result);
        result = regexNumberOrOperand.exec(input);
      }
      return elements;
    };

    Odhner.prototype.isNumber = function(element) {
      var regexNumber;
      regexNumber = /[\d\.\,]+/;
      return regexNumber.test(element);
    };

    Odhner.prototype.numberWithOneOrNoDelimiter = function(input) {
      if (this.sameDelimiterUsedMultpleTimes(input)) {
        return this.removeByRegex(input, /[\.\,]/g);
      } else {
        return this.partBeforeDecimal(input) + this.partFromDecimal(input);
      }
    };

    Odhner.prototype.mostProbableNumber = function(number) {
      var numberWitoutDecimal;
      if (this.isProbableNumber(number)) {
        return number;
      } else {
        numberWitoutDecimal = this.numberWitoutDecimal(number);
        if (this.isProbableNumber(numberWitoutDecimal)) {
          return numberWitoutDecimal;
        } else {
          return number;
        }
      }
    };

    Odhner.prototype.sameDelimiterUsedMultpleTimes = function(input) {
      if (/\..*\./g.test(input) && !/\,/.test(input)) {
        return true;
      } else if (/\,.*\,/g.test(input) && !/\./g.test(input)) {
        return true;
      } else {
        return false;
      }
    };

    Odhner.prototype.partFromDecimal = function(input) {
      var part, regexFirstDecimaFromRight, sanetizedPart;
      regexFirstDecimaFromRight = /[\.\,]\d*$/;
      part = regexFirstDecimaFromRight.exec(input);
      if (part != null) {
        sanetizedPart = part.toString().replace(/[\,]/g, '.');
      }
      if (sanetizedPart != null) {
        return sanetizedPart;
      } else {
        return '';
      }
    };

    Odhner.prototype.partBeforeDecimal = function(input) {
      var part, regexFirstDecimaFromRight, sanetizedPart;
      regexFirstDecimaFromRight = /[\.\,]\d*$/;
      part = this.removeByRegex(input, regexFirstDecimaFromRight);
      sanetizedPart = this.removeByRegex(part, /[\,\.]/g);
      if (sanetizedPart != null) {
        return sanetizedPart;
      } else {
        return '';
      }
    };

    Odhner.prototype.removeByRegex = function(input, regex) {
      if (input != null) {
        return input.toString().replace(regex, '');
      }
    };

    Odhner.prototype.isCriticalNumber = function(input) {
      var regexCriticalNumber;
      regexCriticalNumber = /\d+[\.\,]\d{3}/;
      return regexCriticalNumber.test(input);
    };

    Odhner.prototype.numberWitoutDecimal = function(input) {
      return input.toString().replace(/[\,\.]/g, '');
    };

    Odhner.prototype.isProbableNumber = function(number) {
      var bottomBoarder, topBoarder;
      bottomBoarder = 2;
      topBoarder = bottomBoarder * 1000;
      return number >= bottomBoarder && number < topBoarder;
    };

    Odhner.prototype.compileStringFromArray = function(array) {
      var element, string, _i, _len;
      string = "";
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        element = array[_i];
        string += element;
      }
      return string;
    };

    Odhner.prototype.formattedResult = function(decimalPlaces) {
      return this.format(this.result(this.input), decimalPlaces);
    };

    Odhner.prototype.format = function(number, decimalPlaces) {
      return this.addDelimiters(this.roundNumber(number, decimalPlaces));
    };

    Odhner.prototype.roundNumber = function(number, decimalPlaces) {
      if (decimalPlaces == null) {
        decimalPlaces = 2;
      }
      return number.toFixed(decimalPlaces);
    };

    Odhner.prototype.addDelimiters = function(number) {
      var positiveNumber, prefix, regexSplitByThirdDigit;
      regexSplitByThirdDigit = /(?=(?:\d{3})+(?:\.|$))/g;
      if (/^\-/.test(number)) {
        positiveNumber = /[^\-]+/.exec(number);
        prefix = '-';
      } else {
        positiveNumber = number;
        prefix = '';
      }
      return prefix + positiveNumber.toString().split(regexSplitByThirdDigit).join(",");
    };

    Odhner.split = function(number, parts) {
      var amount;
      number = parseFloat(number);
      parts = parseInt(parts);
      amount = number / parts;
      if (isFinite(amount)) {
        return amount;
      } else {
        return 0;
      }
    };

    Odhner.format = function(input, decimalPlaces) {
      var odhner;
      odhner = new Odhner(input);
      if (odhner.isValid()) {
        return odhner.formattedResult(decimalPlaces);
      } else {
        return input;
      }
    };

    return Odhner;

  })();

  if (typeof jQuery !== "undefined" && jQuery !== null) {
    (function($) {
      return $.fn.odhner = function(options) {
        var settings;
        settings = $.extend({
          onError: function(errors) {
            return alert(errors);
          }
        }, options);
        return this.each(function() {
          return $(this).keydown(function(e) {
            var calculator, input, keyCode;
            keyCode = e.keyCode || e.which;
            if (keyCode !== 13) {
              return;
            }
            e.preventDefault();
            input = $(this).val();
            calculator = new Odhner(input);
            if (calculator.isValid()) {
              return $(this).val(calculator.result());
            } else {
              return settings.onError(calculator.errorsInInput());
            }
          });
        });
      };
    })(jQuery);
  }

  root.Odhner = Odhner;

}).call(this);
